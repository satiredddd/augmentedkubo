<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kubo PH AR</title>
  
  <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
  <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
  
  <style>
    body { 
      margin: 0; 
      overflow: hidden;
      font-family: 'Arial', sans-serif;
    }

    #start-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      color: white;
      padding: 20px;
      box-sizing: border-box;
    }

    #start-screen.hidden {
      display: none;
    }

    #start-screen h1 {
      font-size: 32px;
      margin-bottom: 10px;
    }

    #start-screen p {
      font-size: 16px;
      margin-bottom: 30px;
      text-align: center;
      opacity: 0.9;
    }

    #start-ar-btn {
      background: white;
      color: #667eea;
      border: none;
      padding: 18px 50px;
      border-radius: 30px;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 6px 25px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
    }

    #start-ar-btn:active {
      transform: scale(0.95);
    }

    #start-ar-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .error-message {
      background: rgba(244, 67, 54, 0.9);
      padding: 15px 20px;
      border-radius: 10px;
      margin-top: 20px;
      max-width: 90%;
      text-align: center;
      display: none;
    }

    .error-message.visible {
      display: block;
    }

    #ui-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    #status-bar {
      position: fixed;
      top: 20px;
      left: 20px;
      right: 20px;
      background: rgba(76, 175, 80, 0.9);
      backdrop-filter: blur(10px);
      padding: 15px 20px;
      border-radius: 15px;
      color: white;
      font-size: 14px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      display: none;
    }

    #status-bar.visible {
      display: block;
    }

    #place-button {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 18px 40px;
      border-radius: 30px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 6px 25px rgba(102, 126, 234, 0.5);
      pointer-events: all;
      transition: all 0.3s ease;
      display: none;
    }

    #place-button.visible {
      display: block;
    }

    #place-button:active {
      transform: translateX(-50%) scale(0.95);
    }

    #controls-hint {
      position: fixed;
      bottom: 120px;
      left: 20px;
      right: 20px;
      background: rgba(76, 175, 80, 0.9);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 12px;
      color: white;
      text-align: center;
      font-size: 13px;
      display: none;
      pointer-events: none;
    }

    #controls-hint.visible {
      display: block;
    }

    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 50px;
      height: 50px;
      border: 3px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 0 3px rgba(0, 0, 0, 0.3);
      pointer-events: none;
    }

    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    #crosshair::before {
      top: 50%;
      left: 10px;
      right: 10px;
      height: 3px;
      transform: translateY(-50%);
    }

    #crosshair::after {
      left: 50%;
      top: 10px;
      bottom: 10px;
      width: 3px;
      transform: translateX(-50%);
    }

    a-scene {
      display: none;
    }

    a-scene.visible {
      display: block;
    }
  </style>
</head>

<body>
  <div id="start-screen">
    <h1>ü™ë AR Furniture</h1>
    <p>Place and view 3D furniture in your space using augmented reality</p>
    <button id="start-ar-btn">üöÄ Start AR Experience</button>
    <div id="error-msg" class="error-message"></div>
  </div>

  <div id="ui-overlay">
    <div id="status-bar">
      <span id="status-text">‚ú® AR Active! Point at a flat surface</span>
    </div>

    <div id="crosshair"></div>

    <button id="place-button">üìç Place Chair</button>

    <div id="controls-hint">
      ‚ú® Chair placed!<br>
      ü§è Pinch to scale ‚Ä¢ üîÑ Two fingers to rotate ‚Ä¢ üëâ Drag to move
    </div>
  </div>

  <a-scene
    vr-mode-ui="enabled: false"
    arjs="sourceType: webcam; debugUIEnabled: false; detectionMode: mono_and_matrix; matrixCodeType: 3x3;"
    embedded
    renderer="logarithmicDepthBuffer: true; precision: medium;"
    gesture-detector
    id="scene">

    <a-camera 
      gps-camera 
      rotation-reader
      look-controls-enabled="false">
    </a-camera>

    <a-entity 
      id="furniture"
      visible="false"
      gesture-handler="minScale: 0.3; maxScale: 3">
      
      <a-box 
        position="0 0.5 0" 
        width="0.5" 
        height="0.1" 
        depth="0.5"
        color="#8B4513"
        shadow="cast: true">
      </a-box>
      
      <a-box 
        position="0 0.8 -0.2" 
        width="0.5" 
        height="0.5" 
        depth="0.1"
        color="#8B4513"
        shadow="cast: true">
      </a-box>
      
      <a-cylinder position="-0.2 0.25 -0.2" radius="0.03" height="0.5" color="#654321"></a-cylinder>
      <a-cylinder position="0.2 0.25 -0.2" radius="0.03" height="0.5" color="#654321"></a-cylinder>
      <a-cylinder position="-0.2 0.25 0.2" radius="0.03" height="0.5" color="#654321"></a-cylinder>
      <a-cylinder position="0.2 0.25 0.2" radius="0.03" height="0.5" color="#654321"></a-cylinder>

      <a-circle 
        position="0 0.01 0" 
        radius="0.35" 
        rotation="-90 0 0" 
        color="#000000" 
        opacity="0.3"
        shader="flat">
      </a-circle>

      <a-ring
        position="0 0.02 0"
        radius-inner="0.4"
        radius-outer="0.45"
        color="#4CAF50"
        rotation="-90 0 0"
        opacity="0.6"
        animation="property: rotation; to: -90 360 0; loop: true; dur: 4000; easing: linear">
      </a-ring>

    </a-entity>

    <a-light type="ambient" intensity="0.8"></a-light>
    <a-light type="directional" intensity="0.5" position="1 1 1"></a-light>

  </a-scene>

  <script>
    // Register gesture detector
    AFRAME.registerComponent('gesture-detector', {
      schema: {
        element: { default: '' }
      },

      init: function () {
        this.targetElement = this.data.element && document.querySelector(this.data.element);
        if (!this.targetElement) {
          this.targetElement = this.el;
        }

        this.internalState = {
          previousState: null
        };

        this.emitGestureEvent = this.emitGestureEvent.bind(this);

        this.targetElement.addEventListener('touchstart', this.emitGestureEvent);
        this.targetElement.addEventListener('touchend', this.emitGestureEvent);
        this.targetElement.addEventListener('touchmove', this.emitGestureEvent);
      },

      remove: function () {
        this.targetElement.removeEventListener('touchstart', this.emitGestureEvent);
        this.targetElement.removeEventListener('touchend', this.emitGestureEvent);
        this.targetElement.removeEventListener('touchmove', this.emitGestureEvent);
      },

      emitGestureEvent(event) {
        const currentState = this.getTouchState(event);
        const previousState = this.internalState.previousState;

        const gestureContinues = previousState && currentState && currentState.touchCount == previousState.touchCount;
        const gestureEnded = previousState && !gestureContinues;
        const gestureStarted = currentState && !gestureContinues;

        if (gestureEnded) {
          const eventName = this.getEventPrefix(previousState.touchCount) + 'end';
          this.el.emit(eventName, previousState);
          this.internalState.previousState = null;
        }

        if (gestureStarted) {
          currentState.startTime = performance.now();
          currentState.startPosition = currentState.position;
          currentState.startSpread = currentState.spread;
          const eventName = this.getEventPrefix(currentState.touchCount) + 'start';
          this.el.emit(eventName, currentState);
          this.internalState.previousState = currentState;
        }

        if (gestureContinues) {
          const eventDetail = {
            positionChange: {
              x: currentState.position.x - previousState.position.x,
              y: currentState.position.y - previousState.position.y
            }
          };

          if (currentState.spread) {
            eventDetail.spreadChange = currentState.spread - previousState.spread;
          }

          eventDetail.startPosition = previousState.startPosition;
          eventDetail.position = currentState.position;
          eventDetail.startSpread = previousState.startSpread;
          eventDetail.spread = currentState.spread;

          const eventName = this.getEventPrefix(currentState.touchCount) + 'move';
          this.el.emit(eventName, eventDetail);
          this.internalState.previousState = currentState;
        }
      },

      getTouchState: function (event) {
        if (event.touches.length === 0) return null;

        const touchList = [];
        for (let i = 0; i < event.touches.length; i++) {
          touchList.push(event.touches[i]);
        }

        const touchState = { touchCount: touchList.length };

        const centerX = touchList.reduce((sum, t) => sum + t.clientX, 0) / touchList.length;
        const centerY = touchList.reduce((sum, t) => sum + t.clientY, 0) / touchList.length;
        touchState.position = { x: centerX, y: centerY };

        if (touchList.length >= 2) {
          const dx = touchList[0].clientX - touchList[1].clientX;
          const dy = touchList[0].clientY - touchList[1].clientY;
          touchState.spread = Math.sqrt(dx * dx + dy * dy);
        }

        return touchState;
      },

      getEventPrefix(touchCount) {
        const names = ['one', 'two', 'three', 'many'];
        return names[Math.min(touchCount, 4) - 1] + 'finger';
      }
    });

    // Register gesture handler
    AFRAME.registerComponent('gesture-handler', {
      schema: {
        enabled: { default: true },
        rotationFactor: { default: 5 },
        minScale: { default: 0.3 },
        maxScale: { default: 8 }
      },

      init: function () {
        this.handleScale = this.handleScale.bind(this);
        this.handleRotation = this.handleRotation.bind(this);

        this.initialScale = this.el.object3D.scale.clone();
        this.scaleFactor = 1;

        this.el.sceneEl.addEventListener('onefingermove', this.handleRotation);
        this.el.sceneEl.addEventListener('twofingermove', this.handleRotation);
        this.el.sceneEl.addEventListener('pinchstart', this.handleScale);
        this.el.sceneEl.addEventListener('pinchmove', this.handleScale);
      },

      remove: function () {
        this.el.sceneEl.removeEventListener('onefingermove', this.handleRotation);
        this.el.sceneEl.removeEventListener('twofingermove', this.handleRotation);
        this.el.sceneEl.removeEventListener('pinchstart', this.handleScale);
        this.el.sceneEl.removeEventListener('pinchmove', this.handleScale);
      },

      handleRotation: function (event) {
        if (!this.el.getAttribute('visible')) return;
        
        this.el.object3D.rotation.y += event.detail.positionChange.x * this.data.rotationFactor * 0.01;
        this.el.object3D.rotation.x += event.detail.positionChange.y * this.data.rotationFactor * 0.01;
      },

      handleScale: function (event) {
        if (!this.el.getAttribute('visible')) return;

        if (event.type === 'pinchstart') {
          this.initialScale = this.el.object3D.scale.clone();
        } else {
          const scaleFactor = event.detail.spreadChange / event.detail.startSpread;
          this.scaleFactor = Math.min(Math.max(this.scaleFactor * (1 + scaleFactor * 0.5), this.data.minScale), this.data.maxScale);

          this.el.object3D.scale.set(
            this.initialScale.x * this.scaleFactor,
            this.initialScale.y * this.scaleFactor,
            this.initialScale.z * this.scaleFactor
          );
        }
      }
    });

    // UI Elements
    const startScreen = document.getElementById('start-screen');
    const startBtn = document.getElementById('start-ar-btn');
    const errorMsg = document.getElementById('error-msg');
    const statusBar = document.getElementById('status-bar');
    const statusText = document.getElementById('status-text');
    const placeButton = document.getElementById('place-button');
    const controlsHint = document.getElementById('controls-hint');
    const crosshair = document.getElementById('crosshair');
    const sceneEl = document.getElementById('scene');
    const furniture = document.getElementById('furniture');

    let isPlaced = false;
    let arReady = false;

    // Start AR button click
    startBtn.addEventListener('click', async () => {
      try {
        startBtn.disabled = true;
        startBtn.textContent = '‚è≥ Requesting camera...';
        errorMsg.classList.remove('visible');

        console.log('Requesting camera access...');

        // Request camera permission explicitly
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: 'environment',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          } 
        });

        console.log('Camera access granted!');
        
        // Stop the test stream
        stream.getTracks().forEach(track => track.stop());

        // Show scene and initialize AR
        startBtn.textContent = '‚úì Starting AR...';
        sceneEl.classList.add('visible');

        // Wait for scene to fully load
        setTimeout(() => {
          startScreen.classList.add('hidden');
          statusBar.classList.add('visible');
          placeButton.classList.add('visible');
          arReady = true;
          
          console.log('AR Ready!');

          // Hide status bar after 4 seconds
          setTimeout(() => {
            statusBar.style.opacity = '0';
            setTimeout(() => {
              statusBar.classList.remove('visible');
              statusBar.style.opacity = '1';
            }, 500);
          }, 4000);
        }, 2000);

      } catch (error) {
        console.error('Camera error:', error);
        startBtn.disabled = false;
        startBtn.textContent = 'üöÄ Try Again';
        
        let errorMessage = 'Camera access denied. ';
        
        if (error.name === 'NotAllowedError') {
          errorMessage += 'Please allow camera permissions in your browser settings.';
        } else if (error.name === 'NotFoundError') {
          errorMessage += 'No camera found on this device.';
        } else if (error.name === 'NotReadableError') {
          errorMessage += 'Camera is being used by another app.';
        } else {
          errorMessage += error.message || 'Unknown error occurred.';
        }
        
        errorMsg.textContent = errorMessage;
        errorMsg.classList.add('visible');
      }
    });

    // Place furniture
    placeButton.addEventListener('click', () => {
      if (!arReady) return;

      const camera = document.querySelector('a-camera');
      if (!camera) return;

      const cameraPos = camera.getAttribute('position');
      const cameraRot = camera.getAttribute('rotation');

      const distance = 1.5;
      const radY = THREE.MathUtils.degToRad(cameraRot.y);
      
      const newPos = {
        x: cameraPos.x - Math.sin(radY) * distance,
        y: 0,
        z: cameraPos.z - Math.cos(radY) * distance
      };

      if (!isPlaced) {
        furniture.setAttribute('position', newPos);
        furniture.setAttribute('visible', 'true');
        
        furniture.setAttribute('animation', 
          'property: scale; from: 0 0 0; to: 1 1 1; dur: 500; easing: easeOutElastic');
        
        isPlaced = true;
        placeButton.textContent = '‚úÖ Chair Placed!';
        placeButton.style.background = 'linear-gradient(135deg, #4CAF50 0%, #45a049 100%)';
        
        controlsHint.classList.add('visible');
        crosshair.style.display = 'none';
        
        setTimeout(() => {
          placeButton.textContent = 'üìç Move Chair';
          placeButton.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
          controlsHint.classList.remove('visible');
        }, 3000);
        
      } else {
        furniture.setAttribute('position', newPos);
        
        furniture.setAttribute('animation', 
          'property: scale; from: 1 1 1; to: 1.1 1.1 1.1; dur: 200; direction: alternate; loop: 1');
        
        placeButton.textContent = '‚úÖ Moved!';
        setTimeout(() => {
          placeButton.textContent = 'üìç Move Chair';
        }, 1500);
      }
    });

    console.log('App loaded. Tap "Start AR" to begin.');
  </script>
</body>
</html>